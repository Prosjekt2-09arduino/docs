\chapter{Design and implementation}
In this chapter the design and system architecture of the product will be presented. The reader will learn about how the different components of the product is put together, and how the design of the application was planned.

\section{System architecture}
	The design was divided into several modules:
	\begin{itemize}
		\item{Bluetooth connection between the Android and the Arduino}
		\item{Synchronization with the local SQLite database}
		\item{Android application view (the visible design)}
		\item{A service that contains the protocol for installing ``over the air''}
	\end{itemize}
	\vspace{0.2in}
	
	The system design was implemented such that further developing and extension should be as modular and easy as possible.
	Therefore it was designed as a plugin-like system where you easily can implement your own protocols against a desired device, e.g. Raspberry Pi. The application only supports the STK500 protocol and therefore only connections towards Arduino devices (and with some work other STK500 based devices).
	The design for the connection to other devices was done as shown in Figure~\ref{fig:btconnection_service_stk500}\\

	\begin{figure}[H]
	\centering
	\hspace*{-0.75in}
	\includegraphics[scale=0.85]{images/UML/btconnection_service_stk500.png}
	\caption[BT connection in service]{The Bluetooth connection is stored and managed in a service that provides the STK500 protocol.}
	\label{fig:btconnection_service_stk500}
	\end{figure}

	\textit{Devices} as shown in Figure~\ref{fig:btconnection_service_stk500} is an activity that manages the discovered Bluetooth devices. A device is discovered by listening to the Bluetooth API on the Android. This happens in the \textit{MyBroadcastReceiver} that works like an listener. When this listener gets notified with a device as input, the discovered device will be put in a list in \textit{Devices}.\\

	If the user choose to connect to a device from the list of discovered devices, a service (BtArduinoService) will be created. This service will create and manage the \textit{BluetoothConnection} that manages the Bluetooth connection between the microcontroller (Arduino in this case) and the Android. The service uses \textit{STK500v1} for transfering bytes over the \textit{BluetoothConnection} to the connected device.\\

	To add support for other microcontrollers than Arduino, few changes to Devices.java would have to be done. Another service and a protocol towards a desired device must be implemented, or support for multiple services. Since this project only considers connections between Android and Arduino, only the STK500 protocol and one service was implemented.\\

	The overall design solution for multiple connections will be like in Figure~\ref{fig:otaarchitecture}\\
	\begin{figure}[H]
	\includegraphics[scale=0.7]{figures/OTAArchitecture.pdf}
	\caption[Over The Air Architecture]{The installation module is a class that manages all the services that the application will support. Each service has a protocol for installing over-the-air to a desired microcontroller.}
	\label{fig:otaarchitecture}
	\end{figure}

	The overall system architecture as shown in Figure~\ref{fig:systemarchitecture} illustrates the core components of the system and the relationship between these components. The \textit{Market Application} is the center of the application and is where most the GUI and functionality to the user is taking place. \textit{Device List} is the list of devices that the user can choose from and connect to. It is also here the \textit{Add Device} functionality is, where the user can connect to a device on an alternative way (QR Code or MAC-address).\\

	\begin{figure}[H]
	\centering
	\includegraphics[scale=0.8]{images/System_architecture.png}
	\caption[System Architecture]{This shows the overall system architecture with the most important components.}
	\label{fig:systemarchitecture}
	\end{figure}

	The \textit{Market Application} is the center of the application and is where most the GUI and functionality to the user is taking place. \textit{Device List} is the list of devices that the user can choose from and connect to. It is also here the \textit{Add Device} functionality is, where the user can connect to a device on an alternative way (QR or MAC-address). This is illustrated in Figure~\ref{fig:adddevicescreenuml} \\

	\begin{figure}[H]
	\centering
	\includegraphics[scale=0.85]{images/UML/adddevicescreen.png}
	\caption[UML - AddDeviceScreen]{This is a UML diagram of Add Device Screen. When QR-reader or input-serial is chosen, a new asynchronous task is started that handles the bluetooth connection process.}
	\label{fig:adddevicescreenuml}
	\end{figure}

	The \textit{Service} holds and manages the bluetooth connection (\textit{BluetoothConnection}) and is taking care of the protocol for installing apps on the microcontroller. \\

	The \textit{Memory card} is the memory card on the mobile phone where the database is stored (locally). SQLite was used for database engine because it is common and easy to implement in Android.\\

	\textit{DatabaseHandler} is a class for taking care of the SQL transactions and is the access point for communication with the database. A helper class called \textit{Save} is used for easy access to the \textit{DatabaseHandler}.
	When the application communicates with the Save module, the database communicates with the DatabaseHandler.
	\textit{Save} was created because it can be initialized and created everywhere in the application (in optional java classes) and makes sure its only one instance of the \textit{DatabaseHandler}.

	\subsection{Browse Shop}
	This is the shop where the user can see the $\mu$C apps, choose categories and swipe though different fragments. In  Figure~\ref{fig:categoriesuml} we see the \textit{MainActivity} that is the activity for the category selection of the shop. 
	When a category is selected, a new activity \textit{MainFragmentActivity} (see Figure~\ref{fig:maingui}) is started with the intent information about which category that was selected.

	\begin{figure}[H]
	\centering
	\includegraphics[scale=0.85]{images/UML/categories.png}
	\caption[UML - Categories]{The MainActivity is an activity with a ListView that uses ListAdapterCategory as an adapter. When a category is selected, the ``MainFragmentActivity'' is started with intent information about which category that was selected.}
	\label{fig:categoriesuml}
	\end{figure}

	In Figure~\ref{fig:maingui} the \textit{MainFragmentActivity} is started when a category is selected. This activity creates an FragmentPagerAdapter that manages the fragments. One fragment is one of the views that can be swiped thorugh. \textit{All} and \textit{TopHits} are these fragments. Each fragment consist of a list, and have an Adapter for this list (ListAdapter).

	\begin{figure}[H]
	\hspace*{-1.0in}
	\includegraphics[scale=0.55]{images/UML/main.png}
	\caption[UML - Main GUI]{Here we see a FragmentPagerAdapter that manages all the fragments. Each fragment uses an ListAdapter that structures the list items.}
	\label{fig:maingui}
	\end{figure}

	The \textit{Page} enum is used to tell \textit{MyFragmentPagerAdapter} which category that should be shown in \textit{All} and \textit{TopHits} fragments. This enum is sent as a intent to the MainFragmentActivity when started. When a category is chosen, the content in \textit{All} and \textit{TopHits} are filtered by only showing applications that belongs to the selected category.\\

	\textit{SearchResults} is a class that contains a list of search results ($\mu$C applications) from the search. This class is an activity that have a list like the other fragments, and therefore uses the same list adapter as \textit{All} and \textit{TopHits}. 

	\subsection{STK500v1}
	In Figure~\ref{fig:stk500v1uml} we see blabla

	\begin{figure}[H]
	\hspace*{-1.0in}
	\includegraphics[scale=0.5]{images/UML/stk500v1.png}
	\caption[UML - Main GUI]{description}
	\label{fig:stk500v1uml}
	\end{figure}

\section{Design of Android application}
One of the purposes of the Android application was to ease the process of installing PUIs on an Arduino for non-technical users. As described in section \ref{non-functional}, one of the requirements for the project was that people of all ages are supposed to understand how to use the application. This requirement put pressure on the design, as one have to make sure everyone are able to understand the different functions of the application. \\
\newline
Before the programming of the Android application was started, a complete design guide were created. In this section the complete design of the application is presented. This guide was made for primarily two reasons:
\begin{itemize}
	\item{Presentation for the customer:} With a complete design guide it was possible to present the user interface of the application to the customer before it was programmed. This allowed for input from the customer at an early stage, when it was easier to change the design.
	\item{Avoid confusion:} A design guide reduces the amount of confusion and discussion regarding the appearance of the user interface. When the looks of the user interface was settled before the programming had started, there was less need to discuss this along the way.
\end{itemize}

\subsection{Design guide}
Following is the complete design guide of the Android application. Minor changes were made to some of the screens. In these cases it is commented below the picture. The design of the preferences screen is not shown, as it was unnecessary to design this screen since it is a standard for Android applications.

\paragraph{Screen 1a - Device list}
Screen that shows the list of available Arduino devices. In the final design the list of devices fills the whole screen, and the buttons and description text have switched places. When a device is clicked, a progress bar appears and stays on the screen until a valid Bluetooth connection with the chosen device is made.

\begin{figure}[H]
	\centering
		\includegraphics[scale=0.2]{images/Design_guide/Screen1a.png}
	\caption[Screen 1a - Device list]{The design for the device list of the discovered bluetooth devices}
	\label{fig:screen1a}
\end{figure}


\paragraph{Screen 1b - Add device manually}
Screen that appears after pressing the ``Add device'' button in Screen 1a. It was chosen to remove the ``Bluetooth settings'' button, as it proved unnecessary. In the final design, this screen contains only the ``QR code'' button and ``Input serial'' button, with a short description of the functionality of the button between them.

\begin{figure}[H]
	\centering
		\includegraphics[scale=0.2]{images/Design_guide/Screen1b.png}
	\caption[Screen 1b - Add device manually]{The design for how to add devices alternatively}
	\label{fig:screen1b}
\end{figure}


\paragraph{Screen 1b-i - Input serial}
Screen that appears when the ``Input serial'' button is clicked.

\begin{figure}[H]
\centering
\includegraphics[scale=0.2]{images/Design_guide/Screen1b-i.png}
\caption[Screen 1b-i - Input serial]{The design for input serial popup box.}
\label{fig:screen1bi}
\end{figure}


\paragraph{Screen 2a - Browse shop}
Screen for browsing all the applications for Arduino in the shop. More categories have been added. The user can here swipe left/right to sort the available applications in different ways. See next paragraph.

\begin{figure}[H]
\centering
\includegraphics[scale=0.2]{images/Design_guide/Screen2a.png}
\caption[Screen 2a - Browse shop]{Design for category selection in the shop.}
\label{fig:screen2a}
\end{figure}


\paragraph{Screen 2b - Browse shop by category}
Screen that shows a list of all applications in chosen category. Category ``All'' is chosen.

\begin{figure}[H]
\centering
\includegraphics[scale=0.2]{images/Design_guide/Screen2b.png}
\caption[Screen 2b - Browse shop by category]{Design for the list of application that belongs to the selected category.}
\label{fig:screen2b}
\end{figure}


\paragraph{Screen 3a - Application view}
Screen with overview of an chosen application. Small changes were needed, as the comments field and reviews were given a lower priority at mid-term.

\begin{figure}[H]
\centering
\includegraphics[scale=0.2]{images/Design_guide/Screen3a.png}
\caption[Screen 3a - Application view]{The design for application view. This is the screen you see when you look at the details about an application}
\label{fig:screen3a}
\end{figure}


\paragraph{Screen 3a-i - Installation confirmation}
Screen that appears when the ``Install'' button in Screen 3a is pressed. Shows the name of the chosen device.

\begin{figure}[H]
\centering
\includegraphics[scale=0.2]{images/Design_guide/Screen3a-i.png}
\caption[Screen 3a-i - Installation confirmation]{When the user click ``install'' , this box will show up to warn and confirm the users choice}
\label{fig:screen3ai}
\end{figure}


\paragraph{Screen 3a-ii - Progress of installation}
Screen that shows the progress of the installation. The progress bar cannot be dismissed, so the Android application is locked until the installation is complete or has failed.
The user is warned not to move the Android device out of range of the Arduino.

\begin{figure}[H]
\centering
\includegraphics[scale=0.2]{images/Design_guide/Screen3a-ii.png}
\caption[Screen 3a-ii - Progress of installation]{The progressbar that will shop up during the installation over-the-air.}
\label{fig:screen3aii}
\end{figure}


\paragraph{Screen Xa - Action overflow}
Screen that appears when the ``Action overflow'' button is clicked. This menu is available from all the screen in the application with the exception of the preferences screen.

\begin{figure}[H]
\centering
\includegraphics[scale=0.2]{images/Design_guide/ScreenXa.png}
\caption[Screen Xa - Action overflow]{The menu bar that contains settings and properties.}
\label{fig:screenXa}
\end{figure}

	\subsection{Design decisions}
	This section explains the reasoning behind the different aspects of the design. 

	\textbf{Device list}\\
	It should be simple and fit as many devices as possible, even on the smaller cell phones. As shown in Figure~\ref{fig:screen1a} it was decided to use discovered Bluetooth devices as a primary method of connection to an Arduino. That is why the user will meet this screen first. The less frequently used methods for connecting to an Arduino, like QR codes and serial input, were therefore put separately in another screen, as shown in Figure~\ref{fig:screen1b}. \\

	Because of license compatibility issues, it was necessary to use external QR Code readers. To give the user more flexibility, it is therefore possible for the user to select the optimal QR-reader from his application list.\\

	When serial input is clicked, it was decided to open a dialog box for the input string as shown in Figure~\ref{fig:screen1bi}. This is because it clearly gives the user feedback on what is happening and it does not add unnecessary clutter to the GUI.\\

	\textbf{Browse shop}\\
	The category selection as shown in Figure~\ref{fig:screen2a} was done because it groups the applications, and makes it easier for the user to browse for the more specific applications. The swiping was implemented because it easily and quickly selects what to show. This is a fast way to change what to sort the applications by, and is user friendly on a touch screen. ``Top hits'' and ``All'' were chosen because the database is currently small, and it is not necessary with a large amount of ``sort by'' tabs. Other tabs could be easily implemented if need be.\\

	\textbf{Application view}\\
	The application view, as shown in Figure~\ref{fig:screen3a}, should show all the detail and information about an application that is useful and interesting to the user. Rating, description, developer, application name and images were selected for trying to keep a ``standard''. Meaning that both Google Market and AppStore uses these elements and are expected to be familiar for many users.\\

	When the install button is clicked a confirmation box will pop up as shown in Figure~\ref{fig:screen3ai}. This is because the user might have clicked the button on accident or is not informed about what device he/she is connected to. The device name will therefore be shown in this dialog box.\\

	A progress bar will pop up when the user have confirmed the installation. This is because the application should give an indicator on when the application is complete and when its safe to close the application. \\

	\textbf{Action overflow menu}
	When the user clicks on the action overflow menu, he will expect some sort of settings. That is why this menu contains settings. If the user will hide or show incompatible application to his Arduino, this menu will toggle the preference as shown in Figure~\ref{fig:screenXa}.\\

	\textbf{Changes to the design}
	The action overflow menu have two other options: ``Device List'' and ``Populate Database''. This is because this application is only a prototype and it was necessary to hard code Arduino applications into the Android application. The populate database function will therefore feed the local database with some sample applications.\\

	The device list function is there because it should be possible to change device at all times, not only on startup.\\

	Another change is the ``Welcome Screen''. This is the first screen that will be met when the application is started. This makes it easier to navigate between ``Devices'' and ``Browse Shop''. This screen also provides an option (checkbox) that allows the user to chose wheter or not they will automatically reconnect on startup. Figure~\ref{fig:welcomescreen} shows a simple connection between the reconnect option and the welcome screen.

	\begin{figure}[H]
	\centering
	\includegraphics[scale=0.85]{images/UML/welcomescreen.png}
	\caption[UML - Welcome Screen]{The Welcome Screen will reconnect to last connected device if the user have this option enabled. When the user clicks on ``Devices'' or ``Browse Shop'' a new activity is started.}
	\label{fig:welcomescreen}
	\end{figure}

\section{Database implementation}

	SQLite was used as database language because it is integrated with Android and have much functionality that makes it easy to use in an Android application. Because of changes to priorities the group and the customer got in an agreement to drop the sync adapter, and only use a local database.

	\subsection{Database model}

		In figure~\ref{fig:erdiagram} the database is shown as an ER Diagram. The pictures table was not used because of changes to the teams priorities. Things that had been done before was not important for the customer.

		\begin{figure}[H]
		\includegraphics[scale=1]{images/ER_Diagram.png}
		\caption[ER Diagram]{The ER Diagram describing the setup of the app database.}
		\label{fig:erdiagram}
		\end{figure}

	\subsection{Database details}

		Description and detail about the database tables.

		\subsubsection{Table: app}

			This table contains information about the application.\\

			{\bf \underline{appid}(integer):} auto-increment primary key for applications  \\
			\textbf{name(varchar 160):} name of the application \\
			\textbf{rating(int 10):} rating of the application \\
			\textbf{developerid(int 10):} foreign key to the developer of this application \\
			\textbf{category(varchar 200):} which category this application belongs to \\
			\textbf{description(varchar 200):} description of the application \\
			\textbf{requirementid(int 10):} foreign key to the requirements of this application \\

		\subsubsection{Table: binaryfiles}

			This table contains information about the hex-file (compiled Arduino code). \\
			
			{\bf \underline{binaryfileid}(integer):} auto-increment primary key for binary files \\
			\textbf{appid(int 10):} foreign key to the application that owns this binary file \\
			\textbf{file(BLOB 1000000):} The binary file in a BLOB \\

			A BLOB is not a datatype and stores data exactly as it was input. This database stores it as a binary array.

		\subsubsection{Table: developer}

			This table contains information about the developer.\\
			
			{\bf \underline{developerid}(integer):} auto-increment primary key for developers \\
			\textbf{name(varchar 160):} name of the developer \\
			\textbf{website(varchar 200):} website of the developer \\

		\subsubsection{Table: requirements}

			This table contains the requirements for the application.\\
			
			{\bf \underline{requirementid}(integer):} auto-increment primary key for the requirement \\
			\textbf{name(varchar 160):} name of the requirement \\
			\textbf{description(varchar 200):} description of the requirement \\
			\textbf{compatible(int 10):} integer that is converted to boolean when retrieved from database. \\

			Compatible is an integer of 1 or 0. This indicates if the application referred to is compatible with pagers or not.

		\subsubsection{Table: appusespins}

			This table contains the information about which pins on the Arduino that the application is using.\\
			
			\textbf{appid(int 10):} foreign key to the application that uses this rule \\
			\textbf{requirementid(int 10):} foreign key to the associated requirement \\

